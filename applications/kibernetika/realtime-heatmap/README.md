```text
SPDX-License-Identifier: Apache-2.0
Copyright (c) 2021 Kibernetika, Inc. All rights reserved.
```

# Realtime heatmap

- [Realtime heatmap](#realtime-heatmap)
  - [Application Description](#application-description)
  - [Repository content](#repository-content)
  - [Docker Images](#docker-images)
  - [Pre Requisites](#pre-requisites)
  - [Installation](#installation)
    - [Install the Realtime heatmap](#install-the-realtime-heatmap)
    - [Consumer Application](#consumer-application)
    - [Check application logs to see if it is running](#check-application-logs-to-see-if-it-is-running)

## Application Description

The Application is a Heatmap computing registered in OpenNESS as a producer application. It uses
a streaming pipeline (either server reading from a stream or user pushing the stream to server) and RTMP server.
It utilizes OpenVINO person-detection and person-reidentification models. The application supports heatmap area
computing (general realtime heatmap) and track-heatmap (personal heatmap track connected to a corresponding person, uses
identity anchors).

## Repository content

The repository contains:

-	Helm package for the installation

## Docker Images

Docker images are located at dockerhub:

- kuberlab/realtimeheatmap:1.0.4
- kuberlab/realtimeheatmap:1.0.4-ffmpeg (this one is compiled with Intel-GPU decoding support for FFMpeg)

Pre Requisites
---
The application has been tested on the following software, which is also required:

* [OpenNESS](https://github.com/open-ness/specs) Network Edge v20.12.02
* Kubernetes v1.18.4
* Helm v3.1.2

## Installation

### Install the Realtime heatmap

The installation proccess leverage on helm chart. Go to the `helm` folder of the repository, and edit values.yaml:

Notice environment variables:

- STREAM_COUNT=16 (default 16): Specify the needed number of supported streams.
- TRACKHEATMAP=no/yes (default no): Enable the track heatmap only.
- RUNTIME_HEATMAP=yes/no (default yes): Enable the general heatmap only.
- KSERVING=id (default ''): Specify `serving-id` for audience analytics integration

Notice chart variables:

- openness.heatmapId: Specify the producer application id. Needed in case of existing multiple heatmap applications
integrated with audience
- useHDDL=false/true: Load and run model on HDDL device (or not)
- useIntelGPU=false/true: Use Intel GPU for decoding or not
- runOnVCANode=false/true: Runs workload strictly on VCA card (node).

Run the installation:

```bash
helm install realtime-heatmap ./
```

If the installation succeeds, you will see the additional instructions from `helm` output how to test it.

### Consumer Application

The Consumer application here is the Audience analytics application which consumes frames, heatmap labeling and
resulting video chunks generated by heatmap application. Or, alternatively, there is a way to see the output of heatmap
without consumer application, just see mjpg port (see helm outputs above).

### Check application logs to see if it is running

In order to check application logs, you can see directly the pod logs at:

```bash
pod_name=$(kubectl get po -l app=runtime-heatmap --no-headers | awk '{print $1}')
kubectl logs -f $pod_name
```

### How to implement your own heatmap consumer app

#### General flow

Please refer to the OpenNESS sample application (e.g. openvino app) to see how
is the general flow is performed. The flow should be the following:

- Assume having needed TLS files as described in OpenNESS auth section: `root.pem`, `cert.pem` and `key.pem`
- Connecting to the Edge Application agent (eaa.openness:443) using cert files, sample Python code:

```python
import requests

eaa_server_name = "eaa.openness"
eaa_server_port = "443"
cert_path = "/root/certs/cert.pem"
root_ca_path = "/root/certs/root.pem"
key_path = "/root/certs/key.pem"


client = requests.Session()
base_url = f'https://{eaa_server_name}:{eaa_server_port}'
client.cert = (cert_path, key_path)
client.verify = root_ca_path
```

- Subscribe to notifications, connect using websocket to `wss://eaa.openness:443/notifications`
- Looking up services with `heatmap` namespace
- Subscribe to all that services: `POST https://eaa.openness:443/subscriptions/heatmap <notification-data...>`
- Perform the loop receiving messages from the websocket

#### Message format

General OpenNESS notification format JSON:

```json
{
  "name": "<notification-name>",
  "version": "1.0.0",
  "urn": {
    "id": "runtime-heatmap",
    "namespace": "heatmap"
  },
  "payload": {}
}
```

Where the payload format for the heatmap application is

```json
{
  "stream_id": "stream_id",
  "serving_id": "serving_id",
  "data": "<base64-string-encoded-binary-data>"
}
```

**stream_id** - Stream key of serving
**serving_id** - Serving ID (each serving refers to a container and can contain many streams)
**data** - binary data encoded using base64, and the actual data depends on the notification type.

Data per notification name:

* "heatmap-status": Contains binary jpeg of the heatmap picture, i.e. blended source picture with heatmap colored data.
* "heatmap-db": Contains sqlite DB file data with tables `heatmap-boxes` and `heatmap-data`. `heatmap-data`
  contains aggregated heatmap data for a time period, by default - 60 seconds.
* "heatmap-video": Only for trackmap. Contains video chunk data in mp4 container.

